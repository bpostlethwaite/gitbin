/* 
 * dotjs - collect dotfiles and configs easily for use with git
 *
 * Copyright (c) <2012> Ben Postlethwaite
 * See the file license.txt for copying permission.
 *
 */

"use strict";

//
// ## Module Dependencies ##
//
var path = require('path')
,   async = require('./futil').makeasync()
,   futil = require('./futil').makeutil()
,   errf = require('./errf').errf;



//////////////////////////////////////
// ## Command Namespace ##
// note commands function creates
// a commands object using functional
// inheritance pattern.
//////////////////////////////////////

var commands = function () {
    var that = {}
    ,   my = {} // private object
    ,   e = errf() 
    ,   printusage = true;
 

//
// ## RUN ##
// Main command router
//
    that.run = function (command, args, state, cb) {

        my.args = args;
        my.state = state;

        switch (command) {
        case 'init':
            init(cb);
            break;
        case 'add':
            add(cb);
            break;
        case 'remove':
            remove(cb);
            break;
        case 'bin':
            bin(cb);
            break;
        default:
            cb( errf( ((command === undefined) ? '' : 'Unknown command: ' + command)
                      , printusage), null );
        }
    };
    

//
// ## INIT COMMAND ##
//
    function init ( cb ) {
        console.log( 'Going to initialize: ', process.cwd() );
        cb( null, null )
    };



//
// ## ADD COMMAND ##
//
    function add (cb) {
        var files = my.args; 
        var bin = getActiveBin(getState(), cb);
// Check for file arguements
        if (files.length === 0) {
            cb( errf('<add> command requires file arguments') , null);
        }
// Get bin and run chained processes
        else {
            var processchain = function (arg, cb_) {
                var wantinState
                , source = path.join(process.cwd(),arg)
                , target = bin + '/' + path.basename(arg);
                async.chain( [ checkState, source, wantinState = false] 
                             ,[ futil.copyFile, source, target] 
                             ,[ changeState, source, 'add'] 
                             ,  cb_ );      
            }
            async.asyncMap( files, processchain , function (err, data) {
                if (err) cb(err, null);
                else cb(null, getState());
            });    
        }
    }; // end command.add



//
// ## REMOVE COMMAND ##
//
    function remove (cb) {
        var files = my.args; 
        var bin = getActiveBin(getState(), cb);
// Check for file arguements
        if (files.length === 0) {
            cb( errf('<remove> command requires file arguments') , null);
        }
// Get bin and run chained processes
        else {
            var processchain = function (arg, cb_) {
                var wantinState
                , source = path.join(process.cwd(),arg)
                , target = bin + '/' + path.basename(arg);
                async.chain( [ checkState, source, wantinState = true] 
                             ,[ futil.copyFile, source, target] 
                             ,[ changeState, source, 'add'] 
                             ,  cb_ );      
            }
            async.asyncMap( files, processchain , function (err, data) {
                if (err) cb(err, null);
                else cb(null, getState());
            });    
        }
    }; // end command.add


    

//
// ## BIN COMMAND ##
//
    function bin (cb) {
        var i;
        if (my.args.length > 0) {
            console.log('Don\'t need args with bin command, ignoring.');
        }
        for (i in getState()) {
            console.log( getState()[i].bin );
        }
        cb(null, null);
    }; // end commands bin



// ## GETSTATE ## 
// simple function that returns state.
//
    function getState () {
        return my.state;
    }; 
//
// ## CHECKSTATE ## 
// queries current state
// to ensure status is valid before processing
    function checkState ( item, inState, cb) {
        var i, state = getState();
        for (i in state) {
            if (state[i].active) {
                if (item in state[i].binfiles) {
                    if (inState) cb(null); // Yes we found item and it's good
                    else { //we found item and it's bad
                        cb( errf('Item: ' + e.blue + item
                                 + e.reset + ' is already being tracked.'), null ); 
                    }
                }
                else {
                    if (inState) { // item not found and it is bad
                        cb( errf('Item: ' + e.blue + item 
                                 + e.reset + 'is not in the tracked list.'), null );
                    }
                    else cb(null) // item not found and it's good
                }
            }
        }
    }; // end checkState
//
// ## CHANGESTATE ##
// Modifies the private variable my.state.
// Function allows for multiple state changes
// using a simple API
//
    function changeState ( item, type, cb) {
        var i, state = getState();
        switch (type) {
        case 'add':
            for (i in state) {
                if (state[i].active) {
                    state[i].binfiles[item] = true;
                }
            }
            break;
        case 'rm':
            for (i in state) {
                if (state[i].active) {
                    console.log('functionality not available');
                }
            }
            break;
        default:
            cb(new Error('Wrong arguments for function changeState'));
        }
        my.state = state;
        cb(null);
    }; // end changeState
//
// ## GETACTIVEBIN ##
// Gets active bin also checks bin's path (not yet).
//
    function getActiveBin (state, cb) {
        var i, bin = null;
        for (i in state) {
            if (state[i].active) {
                bin = state[i].bin;
                futil.stats (bin, 'isDirectory', function (err) {
                    if (err) {
                        cb( errf('Problem with path to bin ' 
                                 + e.blue + bin + e.reset), null);
                    }
                });
            }
        }
        if (bin) return bin;
        else {
            cb( errf('No active bin, bug in system', null));
        }
    }; // end getActiveBin



    return that; // Commands returns object with functionality

}; // end commands()


exports.commands = commands;